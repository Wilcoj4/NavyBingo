<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Navy Command Bingo – Go Mode</title>
  <style>
    .cell.bingo .statement,
    .cell.bingo .answer {
      color: #111 !important;
      background: inherit;
      border-color: #FFD700;
    }
    :root {
      --bg: #0f172a;         /* slate-900 */
      --card: #111827;       /* gray-900 */
      --muted: #94a3b8;      /* slate-400 */
      --text: #e5e7eb;       /* gray-200 */
      --accent: #38bdf8;     /* sky-400 */
      --ok: #34d399;         /* emerald-400 */
      --warn: #f59e0b;       /* amber-500 */
      --danger: #ef4444;     /* red-500 */
    }

    html, body { height: 100%; }
    *, *::before, *::after { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica Neue, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      background: linear-gradient(160deg, #0f172a 0%, #111827 60%, #0b1220 100%);
      color: var(--text);
    }

    .container {
      max-width: 1100px;
      margin: 24px auto 64px;
      padding: 0 16px;
    }

    header {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 12px 16px;
      margin-bottom: 16px;
    }

    h1 { font-size: 1.25rem; margin: 0 8px 0 0; }
    .subtitle { color: var(--muted); font-size: 0.95rem; }

    .card {
      background: rgba(31, 41, 55, 0.75);
      backdrop-filter: blur(6px);
      border: 1px solid rgba(255,255,255,0.06);
      border-radius: 16px;
      padding: 16px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.35);
    }

    /* Top form */
    form#metaForm {
      display: grid;
      grid-template-columns: repeat(8, minmax(0, 1fr));
      gap: 12px;
      align-items: end;
    }

    .field {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

      /* Responsive: Make grid scrollable on small screens */
      @media (max-width: 700px) {
        .grid {
          display: block;
          overflow-x: auto;
          white-space: nowrap;
          width: 100vw;
          max-width: 100vw;
          padding-bottom: 8px;
        }
        .cell {
          display: inline-block;
          vertical-align: top;
          min-width: 180px;
          width: 80vw;
          max-width: 90vw;
          margin-right: 8px;
        }
      }
    .field label {
      font-size: 0.8rem;
      color: var(--muted);
      letter-spacing: .02em;
    }

    .field input, .field select {
      background: #0b1020;
      color: var(--text);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 10px;
      padding: 10px 12px;
      outline: none;
    }

    .actions { display: flex; gap: 8px; }

    button {
      appearance: none;
      border: 1px solid rgba(56, 189, 248, .55);
      background: #0b1020;
      color: var(--text);
      padding: 10px 14px;
      border-radius: 10px;
      cursor: pointer;
    }
    button:disabled { opacity: .6; cursor: not-allowed; }

    .hint { color: var(--muted); font-size: 0.85rem; margin-top: 8px; }

    /* Status */
    #csvStatus { margin-top: 8px; font-size: 0.9rem; }
    #csvStatus.ok { color: var(--ok); }
    #csvStatus.warn { color: var(--warn); }
    #csvStatus.error { color: var(--danger); }

    /* Category headers row */
    .categories {
      margin-top: 16px;
      display: grid;
      grid-template-columns: repeat(5, 1fr);
      gap: 12px;
    }
    .cat {
      text-align: center;
      font-weight: 600;
      color: #c7d2fe; /* indigo-200 */
      border-left: 2px solid rgba(99,102,241,0.25);
      border-right: 2px solid rgba(99,102,241,0.25);
      padding: 6px 8px;
      border-radius: 10px;
      background: rgba(79,70,229,0.08);
    }

    /* Bingo grid */
    .grid {
      margin-top: 12px;
      display: grid;
      grid-template-columns: repeat(5, 1fr);
      gap: 12px;
    }

    .cell {
      display: flex;
      flex-direction: column;
      gap: 8px;
      min-height: 154px;
      background: rgba(15, 23, 42, 0.65);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 14px;
      padding: 10px;
      transition: background-color .2s ease, border-color .2s ease, box-shadow .2s ease;
      overflow: hidden; /* keep content within cell */
    }

    .cell.complete { background: rgba(16, 185, 129, 0.22); border-color: rgba(16,185,129,0.5); box-shadow: inset 0 0 0 1px rgba(16,185,129,0.25); }
    .cell.free { background: rgba(56, 189, 248, 0.18); border-color: rgba(56,189,248,0.5); display: grid; place-items: center; text-align: center; font-weight: 800; font-size: 1.25rem; letter-spacing: 0.05em; }
      .cell.bingo {
        background: linear-gradient(135deg, #FFD700 60%, #FFF8DC 100%);
        border-color: #FFD700;
        box-shadow: 0 0 12px 2px #FFD70099, 0 0 0 2px #FFF8DC;
        an
        position: relative;
      }
      .cell.bingo::after {
        content: "";
        position: absolute;
        inset: 0;
        border-radius: 14px;
        pointer-events: none;
        box-shadow: 0 0 16px 4px #FFD70055;
      }

    .statement { font-size: 0.95rem; line-height: 1.35; color: #e5e7eb; }

    .answer {
      width: 100%;
      max-width: 100%;
      background: #0b1020;
      color: var(--text);
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 8px;
      padding: 8px 9px;
      outline: none;
      resize: vertical;        /* let user expand if needed */
      overflow: hidden;        /* we auto-grow */
      min-height: 40px;
      max-height: 180px;
      line-height: 1.3;
      font-size: 1rem;
    }

    footer { margin-top: 18px; color: var(--muted); font-size: 0.85rem; }
    .small { font-size: .8rem; color: var(--muted); }

    @media print {
      body { background: white; color: black; }
      .card { box-shadow: none; background: white; border: none; }
      button, .hint, #csvStatus { display: none !important; }
      .cell { border: 1px solid #333; }
      .cell.free { background: #e0f2fe !important; }
      .cell.complete { background: #d1fae5 !important; }
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>Command Bingo</h1>
      <div class="subtitle">Single‑button flow: "Go" will load or create your card</div>
    </header>

    <section class="card">
      <form id="metaForm">
        <div class="field" style="grid-column: span 2;">
          <label for="date">Date</label>
          <input type="date" id="date" required />
        </div>
        <div class="field">
          <label for="rank">Rank</label>
          <input type="text" id="rank" placeholder="e.g., E‑5 / PO2" required />
        </div>
        <div class="field">
          <label for="first">First name</label>
          <input type="text" id="first" required />
        </div>
        <div class="field">
          <label for="last">Last name</label>
          <input type="text" id="last" required />
        </div>
        <div class="actions" style="grid-column: span 8;">
          <button type="button" id="goBtn" title="Load saved or create a new card for this person">Go</button>
        </div>
      </form>

      <div class="hint">Data source: <code>CommandBingo_fix.csv</code> is auto‑loaded from the server.</div>
      <div id="csvStatus" class="warn">Loading data…</div>

      <div id="categories" class="categories" aria-live="polite"></div>
      <div id="grid" class="grid" role="grid" aria-label="Bingo grid"></div>
      <div class="small" style="margin-top:8px;">Cells turn green when answered. Click Save to update bingo highlights.</div>
    </section>

    <footer>
      <div class="small">Go‑Mode v2 – HTML/CSS/JS only. Data saved per user/date to <code>localStorage</code>.</div>
    </footer>
  </div>

  <script>
    // --- CSV parser (quoted fields + escaped quotes) ---
    function parseCSV(text) {
      const rows = [];
      let i = 0, cur = '', row = [], inQuotes = false;
      while (i < text.length) {
        const ch = text[i];
        if (inQuotes) {
          if (ch === '"') {
            if (text[i + 1] === '"') { cur += '"'; i++; }
            else { inQuotes = false; }
          } else { cur += ch; }
        } else {
          if (ch === '"') { inQuotes = true; }
          else if (ch === ',') { row.push(cur); cur = ''; }
else if (ch === '\n') { row.push(cur); rows.push(row); row = []; cur = ''; }
else if (ch === '\r') { /* ignore */ }
          else { cur += ch; }
        }
        i++;
      }
      if (cur.length > 0 || row.length > 0) { row.push(cur); rows.push(row); }
      return rows;
    }

    // --- Utilities ---
    const $ = (sel) => document.querySelector(sel);
    const gridEl = $('#grid');
    const catsEl = $('#categories');
    const csvStatus = $('#csvStatus');

    function todayStr() {
      const d = new Date();
      const pad = (n) => String(n).padStart(2, '0');
      return `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())}`;
    }

    function storageKey(meta) {
      const clean = (s) => (s || '').trim().toUpperCase();
      return `bingo:${meta.date}:${clean(meta.rank)}:${clean(meta.first)}:${clean(meta.last)}`;
    }

    function saveState() {
      if (!currentMeta) return;
      const key = storageKey(currentMeta);
      const state = { meta: currentMeta, categories: currentCategories, grid: currentGrid, answers: currentAnswers, savedAt: new Date().toISOString() };
      localStorage.setItem(key, JSON.stringify(state));
      lastSavedKey = key;
    }

    function tryLoad(meta) {
      const key = storageKey(meta);
      const raw = localStorage.getItem(key);
      if (!raw) return null;
      try { return JSON.parse(raw); } catch { return null; }
    }

    function pickN(arr, n) {
      const a = arr.slice();
      for (let i = a.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [a[i], a[j]] = [a[j], a[i]];
      }
      return a.slice(0, n);
    }

    function clearGrid() { gridEl.innerHTML = ''; catsEl.innerHTML = ''; }

    function renderCategories(headers) {
      catsEl.innerHTML = '';
      headers.forEach(h => {
        const div = document.createElement('div');
        div.className = 'cat';
        div.textContent = h || '';
        catsEl.appendChild(div);
      });
    }

    function cellId(r, c) { return `r${r}c${c}`; }

    function autoFit(el) {
      // Grow height to fit content up to max-height; tweak font for long strings
      el.style.height = 'auto';
      const newH = Math.min(el.scrollHeight, 180);
      el.style.height = newH + 'px';
      const len = (el.value || '').length;
      let fs = 16; // px
      if (len > 80) fs = 13;
      else if (len > 50) fs = 14;
      el.style.fontSize = fs + 'px';
    }

    function renderGridFromState(state) {
      clearGrid();
      renderCategories(state.categories.headers);
      const freeR = 2, freeC = 2;
      // Helper to check if a cell is complete (answered or free)
      function isCellComplete(r, c) {
        if (r === freeR && c === freeC) return true;
        const id = cellId(r, c);
        return (state.answers[id] || '').trim().length > 0;
      }

      // Bingo detection
      function getBingoLines() {
        const lines = [];
        // Rows
        for (let r = 0; r < 5; r++) {
          let bingo = true;
          for (let c = 0; c < 5; c++) {
            if (!isCellComplete(r, c)) { bingo = false; break; }
          }
          if (bingo) lines.push({ type: 'row', idx: r });
        }
        // Columns
        for (let c = 0; c < 5; c++) {
          let bingo = true;
          for (let r = 0; r < 5; r++) {
            if (!isCellComplete(r, c)) { bingo = false; break; }
          }
          if (bingo) lines.push({ type: 'col', idx: c });
        }
        // Diagonal TL-BR
        let bingoDiag1 = true;
        for (let i = 0; i < 5; i++) {
          if (!isCellComplete(i, i)) { bingoDiag1 = false; break; }
        }
        if (bingoDiag1) lines.push({ type: 'diag', idx: 1 });
        // Diagonal TR-BL
        let bingoDiag2 = true;
        for (let i = 0; i < 5; i++) {
          if (!isCellComplete(i, 4 - i)) { bingoDiag2 = false; break; }
        }
        if (bingoDiag2) lines.push({ type: 'diag', idx: 2 });
        return lines;
      }

      // Get bingo cells
      function getBingoCells(lines) {
        const cells = new Set();
        lines.forEach(line => {
          if (line.type === 'row') {
            for (let c = 0; c < 5; c++) cells.add(cellId(line.idx, c));
          } else if (line.type === 'col') {
            for (let r = 0; r < 5; r++) cells.add(cellId(r, line.idx));
          } else if (line.type === 'diag' && line.idx === 1) {
            for (let i = 0; i < 5; i++) cells.add(cellId(i, i));
          } else if (line.type === 'diag' && line.idx === 2) {
            for (let i = 0; i < 5; i++) cells.add(cellId(i, 4 - i));
          }
        });
        return cells;
      }

      const bingoLines = getBingoLines();
      const bingoCells = getBingoCells(bingoLines);
      for (let r = 0; r < 5; r++) {
        for (let c = 0; c < 5; c++) {
          const id = cellId(r,c);
          const cell = document.createElement('div');
          cell.className = 'cell';
          cell.dataset.cellId = id;
          if (bingoCells.has(id)) cell.classList.add('bingo');

          if (r === freeR && c === freeC) {
            cell.classList.add('free');
            cell.innerHTML = '<div>FREE<br/>SPACE</div>';
          } else {
            const stmt = state.grid[id]?.statement || '';
            const stmtEl = document.createElement('div');
            stmtEl.className = 'statement';
            stmtEl.textContent = stmt;

            const ansEl = document.createElement('textarea');
            ansEl.className = 'answer';
            ansEl.placeholder = 'Answer…';
            ansEl.value = state.answers[id] || '';
            autoFit(ansEl);

            ansEl.addEventListener('input', () => {
              currentAnswers[id] = ansEl.value;
              autoFit(ansEl);
              if (ansEl.value.trim().length > 0) cell.classList.add('complete');
              else cell.classList.remove('complete');
              debouncedSave();
              updateBingoHighlights();
            });

            if ((state.answers[id] || '').trim().length > 0) cell.classList.add('complete');

            cell.appendChild(stmtEl);
            cell.appendChild(ansEl);
          }

          gridEl.appendChild(cell);
        }
      }
    }

    // Update bingo highlights in-place
    function updateBingoHighlights() {
      const freeR = 2, freeC = 2;
      function isCellComplete(r, c) {
        if (r === freeR && c === freeC) return true;
        const id = cellId(r, c);
        return (currentAnswers[id] || '').trim().length > 0;
      }
      function getBingoLines() {
        const lines = [];
        for (let r = 0; r < 5; r++) {
          let bingo = true;
          for (let c = 0; c < 5; c++) {
            if (!isCellComplete(r, c)) { bingo = false; break; }
          }
          if (bingo) lines.push({ type: 'row', idx: r });
        }
        for (let c = 0; c < 5; c++) {
          let bingo = true;
          for (let r = 0; r < 5; r++) {
            if (!isCellComplete(r, c)) { bingo = false; break; }
          }
          if (bingo) lines.push({ type: 'col', idx: c });
        }
        let bingoDiag1 = true;
        for (let i = 0; i < 5; i++) {
          if (!isCellComplete(i, i)) { bingoDiag1 = false; break; }
        }
        if (bingoDiag1) lines.push({ type: 'diag', idx: 1 });
        let bingoDiag2 = true;
        for (let i = 0; i < 5; i++) {
          if (!isCellComplete(i, 4 - i)) { bingoDiag2 = false; break; }
        }
        if (bingoDiag2) lines.push({ type: 'diag', idx: 2 });
        return lines;
      }
      function getBingoCells(lines) {
        const cells = new Set();
        lines.forEach(line => {
          if (line.type === 'row') {
            for (let c = 0; c < 5; c++) cells.add(cellId(line.idx, c));
          } else if (line.type === 'col') {
            for (let r = 0; r < 5; r++) cells.add(cellId(r, line.idx));
          } else if (line.type === 'diag' && line.idx === 1) {
            for (let i = 0; i < 5; i++) cells.add(cellId(i, i));
          } else if (line.type === 'diag' && line.idx === 2) {
            for (let i = 0; i < 5; i++) cells.add(cellId(i, 4 - i));
          }
        });
        return cells;
      }
      const bingoLines = getBingoLines();
      const bingoCells = getBingoCells(bingoLines);
      for (let r = 0; r < 5; r++) {
        for (let c = 0; c < 5; c++) {
          const id = cellId(r, c);
          const cell = gridEl.querySelector(`[data-cell-id="${id}"]`);
          if (!cell) continue;
          if (bingoCells.has(id)) cell.classList.add('bingo');
          else cell.classList.remove('bingo');
        }
      }
    }
    // Initial bingo highlight
    setTimeout(updateBingoHighlights, 0);

    function generateNewGrid() {
      if (!csvData || !csvData.columns || csvData.columns.length !== 5) {
        alert('Data not loaded or does not have exactly 5 columns.');
        return;
      }
      const freeR = 2, freeC = 2;
      currentGrid = {};
      currentAnswers = {};

      for (let c = 0; c < 5; c++) {
        const needed = c === 2 ? 4 : 5; // middle column has a free center
        const choices = pickN(csvData.columns[c], needed);
        let idx = 0;
        for (let r = 0; r < 5; r++) {
          if (r === freeR && c === freeC) continue; // free space
          const id = cellId(r,c);
          currentGrid[id] = { row: r, col: c, statement: choices[idx++] || '' };
        }
      }

      currentCategories = { headers: csvData.headers.slice() };
      renderGridFromState({ categories: currentCategories, grid: currentGrid, answers: currentAnswers });
      debouncedSave();
    }

    function ensureMeta() {
      const meta = {
        date: $('#date').value,
        rank: $('#rank').value,
        first: $('#first').value,
        last: $('#last').value,
      };
      if (!meta.date || !meta.rank || !meta.first || !meta.last) {
        alert('Please complete Date, Rank, First, and Last to continue.');
        return null;
      }
      currentMeta = meta;
      return meta;
    }

    // --- Debounced save ---
    let saveTimer = null, lastSavedKey = null;
    const debouncedSave = () => { clearTimeout(saveTimer); saveTimer = setTimeout(saveState, 200); };

    // --- Data handling (CSV only, from server) ---
    let csvData = null; // { headers:[], columns:[[],[],[],[],[]] }

    function processCSVText(text) {
      const rows = parseCSV(text).filter(r => r.length && r.some(v => (v||'').trim().length));
      if (!rows.length) throw new Error('CSV is empty');
      const headers = rows[0].slice(0,5);
      const columns = [[],[],[],[],[]];
      for (let i = 1; i < rows.length; i++) {
        for (let c = 0; c < 5; c++) {
          const val = (rows[i][c] || '').trim();
          if (val) columns[c].push(val);
        }
      }
      if (columns.some(col => col.length === 0)) {
        csvStatus.className = 'error';
        csvStatus.textContent = 'CSV error: one or more columns are empty.';
        return;
      }
      csvData = { headers, columns };
      csvStatus.className = 'ok';
      csvStatus.textContent = `CSV loaded: ${columns.map(c => c.length).join(' / ')} items per column`;
    }

    async function tryFetchCSV() {
      csvStatus.className = 'warn';
      csvStatus.textContent = 'Loading CommandBingo_fix.csv…';
      const urls = ['/static/CommandBingo_fix.csv', 'CommandBingo_fix.csv'];
      for (const u of urls) {
        try {
          const res = await fetch(u, { cache: 'no-store' });
          if (!res.ok) throw new Error('HTTP ' + res.status);
          const text = await res.text();
          processCSVText(text);
          return;
        } catch (e) { /* try next */ }
      }
      csvStatus.className = 'error';
      csvStatus.textContent = 'Could not fetch CommandBingo_fix.csv from server.';
    }

    // --- Global state ---
    let currentMeta = null;
    let currentCategories = null;
    let currentGrid = {};
    let currentAnswers = {};

    // --- Wire up UI ---
    document.addEventListener('DOMContentLoaded', () => {
      $('#date').value = todayStr();
      tryFetchCSV();

      // Single-button flow
      $('#goBtn').addEventListener('click', () => {
        const meta = ensureMeta();
        if (!meta) return;
        const saved = tryLoad(meta);
        if (saved) {
          currentMeta = saved.meta;
          currentCategories = saved.categories;
          currentGrid = saved.grid || {};
          currentAnswers = saved.answers || {};
          renderGridFromState(saved);
          csvStatus.className = 'ok';
          csvStatus.textContent = 'Loaded saved card.';
        } else {
          if (!csvData) { alert('CSV not yet loaded from server.'); return; }
          generateNewGrid();
          csvStatus.className = 'ok';
          csvStatus.textContent = 'Generated new card.';
        }
      });

      // Save button updates bingo highlights
      $('#saveBtn').addEventListener('click', () => {
        renderGridFromState({ categories: currentCategories, grid: currentGrid, answers: currentAnswers });
      });
    });
  </script>
</body>
</html>
